#ifndef XSECLOOPER_H
#define XSECLOOPER_H

class TH1D;
class TH2D;
class TGraph;
namespace PlotUtils
{
class MnvH1D;
class MnvH2D;
}

#include "TSpline.h"
#include "TVector3.h"

#include "ChainWrapper.h"
#include <vector>
#include <set>

#include "XSec.h"

#include "PlotUtils/weightRPA.h"
#include "PlotUtils/weight_2p2h.h"
#include "PlotUtils/FluxReweighter.h" //Needed for EPlaylist :(

//Eroica MC fractions found with MinervaMaterialScanAlg
//Minerva_v10r8p12/Ana/PlotUtils/PlotUtils/TargetUtils.h
namespace EroicaAtomicMass
{
  const double C  = 12.0107;
  const double H  = 1.00794;
  const double O  = 15.9994;
  const double Ti = 47.867;
  const double Al = 26.982;
  const double Si = 28.0855;
  const double Cl = 35.453;
  
  const double Fe = (.99*55.845 + .01*54.938045); //99% Fe, 1% Mn
  const double Pb = 207.2;
};

//no need to update to Anne's revision for old MC production, which was generated by the Eroica numbers (which is at the moment outdated)
//http://cdcvs.fnal.gov/cgi-bin/public-cvs/cvsweb-public.cgi/AnalysisFramework/Ana/PlotUtils/PlotUtils/TargetUtils.h?rev=1.10.4.3;content-type=text%2Fplain;cvsroot=mnvsoft
namespace EroicaMassFractionMC
{
  const double C  = 0.8784;
  const double H  = 0.0819;
  const double O  = 0.0286;
  const double Ti = 0.0046;
  const double Al = 0.0013;
  const double Si = 0.0014;
  const double Cl = 0.0038;
};

namespace NXAtomicMass
{
  const double C  = 12.0107;
  const double H  = 1.00794;
  const double O  = 15.9994;
  const double Ti = 47.867;
  const double Al = 26.982;
  const double Si = 28.0855;
  const double Cl = 35.453;
  
  const double Fe = (.99*55.845 + .01*54.938045); //99% Fe, 1% Mn
  const double Pb = 207.2;
}

namespace NXMassFractionMC
{
  const double C  = 0.8851;
  const double H  = 0.0818;
  const double O  = 0.0250;
  const double Ti = 0.0047;
  const double Al = 0.0007;
  const double Si = 0.0007;
  const double Cl = 0.0020;
}

// A class that knows how to loop over truth trees and produce cross
// section histograms. Holds a vector of XSec objects, each of which
// knows what selection it's implementing and what variable it's
// drawing, while XSecLooper handles the overall normalization/flux,
// which is calculated from the number of CC events on carbon divided
// by the corresponding cross section from the GENIE spline.
class XSecLooper
{
public:
  enum{
    ProtonNonInteracting,
    ProtonAcceleration,
    ProtonDeceleration,
    PionAbsorption,
    NOFSI
  };

  // Construct an XSecLooper and use the files defined by the
  // inputFileGlob, which should each contain a tree called
  // 'Truth'. Note that inputFileGlob is a proper unix glob, and not a
  // ROOT-style glob, so, eg "foo/*/*.root" will add all root files in
  // all subdirectories of foo/.
  explicit XSecLooper(const char* inputFileGlob);

  // Destructor. Destructs.
  virtual ~XSecLooper();

  // Add the files specified by inputFileGlob to the chain. Note that
  // inputFileGlob is a proper unix glob, and not a ROOT-style glob,
  // so, eg "foo/*/*.root" will add all root files in all
  // subdirectories of foo/.
  void addFiles(const char* inputFileGlob);

  // Add an XSec object to this XSecLooper
  void addXSec(XSec* xsec);

  // What incoming neutrino type are we considering?
  void setNuPDG(int nuPDG) { clearNuPDGs(); addNuPDG(nuPDG); };  // only want a single nu
  void addNuPDG(int nuPDG) { m_nuPDGs.insert(nuPDG); };
  void clearNuPDGs() { m_nuPDGs.clear(); };
  const std::set<int>& getNuPDGs() const { return m_nuPDGs; };

  // What fiducial volume are we using?
  void setFiducial(const double zMin, const double zMax, const double apothem = 850)
  {
    m_useFiducialBranch = false;
    m_fiducialZMin = zMin;
    m_fiducialZMax = zMax;
    m_apothem = apothem;
  }

  // What playlist's flux are we using?
  void setPlaylist(const PlotUtils::FluxReweighter::EPlaylist playlist) { m_playlist = playlist; }

  //Number of Universes to be used
  void setNumUniv(int nUniv) { m_nUniv=nUniv; }
  int getNumUniv() const { return m_nUniv; }

  // Manually set the spline name corresponding to the channel selected in isCCRateEvent.
  // The default is "", which means it will form the name for total CC on C12 for you
  void setRateSplineName( TString& spline ) { m_rateSplineName = spline; }

  void GetMotherFSIParticles( std::vector<unsigned int>& particles, const int entry ) const;
  void GetFSParticles( int& pionindex, int& protonid, const int entry ) const;
  bool IsMuonCollinear(const TVector3 selectedp, const int entry) const;
  bool IsScaled(const TVector3 selectedp, const TVector3 primaryproton) const;
  static string FSIName(const int imode);
  void PrintProton(const int fsitype, int & kprint, const int entry, const int protonindex, const int it_primary_proton) const;
  int FSIType(const int entry, const int protonindex) const;

  // Actually run the loop to fill all the histograms and calculate
  // the cross sections. setNuPDG must have been called before this.
  // Set entries to force the number of entries to loop over.
  void runLoop(const int entries = 0, const int fsitarget = -999);


  ///these functions get you your 2p2h and rpa weights.
  //2p2h and rpa classes
  PlotUtils::weight_2p2h *weight_cv_2p2h;
  PlotUtils::weightRPA *weight_cv_and_var_RPA;

  double GetTrueQ3(const int entry);
  double GetTrueQ0(const int entry);
  double Get2p2hWeight(const int entry);
  double GetRPAWeight(const int entry);

  
  // Get the list of XSec objects that we're dealing with
  const std::vector<XSec*>& getXSecs() const { return m_xsecs; }

  // Get the flux histogram, calculated as the ratio of the number of
  // CC events on carbon to the CC cross section spline. The flux
  // histogram is really (flux)*(number of C12)*(pot)
  virtual TH1* getFluxHist();


protected:

  // This is a class to wrap a TSpline3 created to interpolate a
  // histogram in such a way that we can wrap it in a TF1. We go to
  // these lengths to be able to use TF1::Integral() to integrate the
  // flux without worrying about bin edge effects and my general
  // incompetence with writing numerical integration functions
  class HistSpline
  {
  public:
    HistSpline(TH1* h)
    {
      spline=new TSpline3(h);
    }
    
    ~HistSpline() { delete spline; }
    
    double operator()(double* x, double*)
    {
      return spline->Eval(x[0]);
    }
    
  private:
    TSpline3* spline;
  };

  class GraphSpline
  {
  public:
    GraphSpline(TGraph* g)
    {
      spline=new TSpline3( (std::string("graphspline") + g->GetName()).c_str(),g);
    }

    ~GraphSpline() { delete spline; };

    double operator()(double* x, double*)
    {
      return spline->Eval(x[0]);
    }

  private:
    TSpline3* spline;
  };

  
  // Is the event in your fiducial volume?  If you need a
  // different fiducial volume, subclass XSecLooper and override this
  // Default is to use isFiducialTracker.
  virtual bool isFiducial(ChainWrapper& chw, int entry);
  //=================================
  // functions for flux normalization
  //=================================
  // Is this event used for the normalization histogram?
  virtual bool isCCRateEvent(ChainWrapper& chw, int entry);
  // Is the event in the tracker fiducial volume?
  // Used for total event rate calcuclation and normalization.
  virtual bool isFiducialTracker(ChainWrapper& chw, int entry);
  // Get the total CC cross section on carbon spline from the GENIE file
  virtual TGraph* getCCSpline(int pdg);
  // Take a number of events vs Enu histogram and divide out the flux
  // to turn it into a total cross section histogram
  void normalizeEnuHist(PlotUtils::MnvH1D* h);
  // Get the normalization factor to turn a "per C12" histogram into a
  // "per normType" histogram
  double getNormFactor(const XSec& xsec);
  // Divide the contents of each bin in h by their width (to turn a
  // ROOT histogram into an actual histogram)
  void divideBinsByWidth(PlotUtils::MnvH1D* h);
  void divideBinsByWidth(PlotUtils::MnvH2D* h);

  // Are you applying any additional weight to the CV (in addition to the standard cv weight)
  virtual double getSignalWeight(ChainWrapper & chw, int entry);
  //Vector of weights coming from GENIE
  std::vector<double> getGenV(ChainWrapper & chw, int entry);

  std::vector<XSec*> m_xsecs; // The cross sections we're dealing with
  ChainWrapper* m_chw;        // The ChainWrapper for the truth chain
  std::map<int, PlotUtils::MnvH1D*> m_ccRateHists;      // The number of CC events on carbon histogram
  TH1D* m_fluxHist;           // The flux histogram (flux*NC12*pot)
  std::set<int> m_nuPDGs;     // PDG code(s) for the neutrino type we care about
  int m_nUniv;                // Number of universes to be used
  TString m_rateSplineName;   // User specified spline name used to extract flux from cc rate histogram.
  double m_fiducialZMin;
  double m_fiducialZMax;
  double m_apothem;
  bool m_useFiducialBranch;
  PlotUtils::FluxReweighter::EPlaylist m_playlist;

  public:
    TH1D * fluxAvg;

};

#endif
